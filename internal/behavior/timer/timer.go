package timer

import (
	"context"
	"sync"
	"time"

	"github.com/pbaity/lex/internal/logger"
	"github.com/pbaity/lex/internal/queue"
	"github.com/pbaity/lex/pkg/models"
)

// TimerService manages the execution of configured timers.
type TimerService struct {
	config      *models.Config
	eventQueue  *queue.EventQueue
	wg          sync.WaitGroup
	cancelFuncs map[string]context.CancelFunc // Map timer ID to its context cancel func
	mu          sync.Mutex                    // Protects cancelFuncs map
}

// NewService creates a new TimerService.
func NewService(cfg *models.Config, eq *queue.EventQueue) *TimerService {
	return &TimerService{
		config:      cfg,
		eventQueue:  eq,
		cancelFuncs: make(map[string]context.CancelFunc),
	}
}

// Start initializes and starts goroutines for each configured timer.
func (s *TimerService) Start() error {
	l := logger.L()
	if len(s.config.Timers) == 0 {
		l.Info("No timers configured.")
		return nil
	}

	l.Info("Starting timer service...")
	s.mu.Lock()
	defer s.mu.Unlock()

	for _, timerCfg := range s.config.Timers {
		// Capture loop variable for closure
		cfg := timerCfg

		if cfg.Interval.Duration <= 0 {
			l.Error("Timer configured with invalid interval, skipping.", "timer_id", cfg.ID, "interval", cfg.Interval.Duration)
			continue
		}

		// Validate that the associated action exists (should also be done during config load validation)
		if _, found := s.findActionConfig(cfg.ActionID); !found {
			l.Error("Action config not found for timer, skipping.", "timer_id", cfg.ID, "action_id", cfg.ActionID)
			continue
		}

		ctx, cancel := context.WithCancel(context.Background())
		s.cancelFuncs[cfg.ID] = cancel

		s.wg.Add(1)
		go s.runTimer(ctx, cfg)
		l.Info("Started timer", "timer_id", cfg.ID, "interval", cfg.Interval.Duration.String(), "action_id", cfg.ActionID)
	}
	l.Info("Timer service started")
	return nil
}

// Stop signals all running timer goroutines to stop and waits for them.
func (s *TimerService) Stop() error {
	l := logger.L()
	if len(s.config.Timers) == 0 {
		l.Info("No timers configured, skipping stop.")
		return nil
	}

	l.Info("Stopping timer service...")
	s.mu.Lock()
	for id, cancel := range s.cancelFuncs {
		l.Debug("Cancelling timer context", "timer_id", id)
		cancel()
	}
	// Clear the map after cancelling all
	s.cancelFuncs = make(map[string]context.CancelFunc)
	s.mu.Unlock()

	s.wg.Wait() // Wait for all timer goroutines to finish
	l.Info("Timer service stopped")
	return nil
}

// runTimer is the main loop for a single timer goroutine.
func (s *TimerService) runTimer(ctx context.Context, cfg models.TimerConfig) {
	defer s.wg.Done()
	l := logger.L().With("timer_id", cfg.ID, "action_id", cfg.ActionID)
	l.Info("Timer routine started")

	// Ticker for periodic execution
	ticker := time.NewTicker(cfg.Interval.Duration)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			l.Info("Timer routine stopping due to context cancellation.")
			return
		case <-ticker.C:
			l.Info("Timer triggered by interval, enqueuing action")

			// Create and enqueue the event for the associated action
			event := models.Event{
				// ID generated by Enqueue
				SourceID:  cfg.ID,
				Type:      models.EventTypeTimer,
				ActionID:  cfg.ActionID,
				Timestamp: time.Now().UTC(),
				// Timers typically don't have dynamic parameters unless predefined in config?
				Parameters: make(map[string]string),
			}

			if enqueueErr := s.eventQueue.Enqueue(event); enqueueErr != nil {
				l.Error("Failed to enqueue event from timer", "error", enqueueErr)
				// Decide on error handling: retry enqueue? Log and continue?
			}
		}
	}
}

// findActionConfig is a helper to get the action configuration by ID.
// Duplicated from watcher service - consider moving to a shared utility or config helper.
func (s *TimerService) findActionConfig(actionID string) (*models.ActionConfig, bool) {
	for _, action := range s.config.Actions {
		if action.ID == actionID {
			return &action, true
		}
	}
	return nil, false
}
